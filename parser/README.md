# About COOL Parser implementation
There are three Python Files for implementing COOL parser.
The Python codes have been split into three files to improve readability.

1. main.py: The core parser that works with a lexer to parse tokenized
input from .cl-lex files. It follows grammar rules specific to the COOL
language to generate an AST.
2. lexer_cl.py: The lexer that tokenizes input programs written in COOL.
It breaks down the source code into tokens like keywords, identifiers,
operators, and literals.
3. output_ast.py: This class handles the output formatting of the AST
generated by the parser. It provides structured output of the AST for
inspection or further processing.

And there are two COOL files to test for positive and negative cases.

1. good.cl: A sample COOL program that follows the correct syntax.
This file is used for testing and demonstrating how the parser processes
a valid COOL program.
2. bad.cl: A COOL program containing syntax errors, used to showcase the
parser's error-handling capabilities.

## About lexer_cl.py
The lexer breaks down a .cl file into tokens.
These tokens represent the fundamental elements of the COOL language
such as keywords (class, if, else, etc.), operators (+, -, *, /),
and identifiers (variable and function names).

DummyLexer Class: This lexer reads .cl-lex files and provides tokens
for the parser. Each token includes:
1. Type: The kind of token (e.g., identifier, keyword, operator).
2.Value: The actual value of the token (e.g., a variable name or number).
3. Line Number: The line in the source code where the token appeared.


## About output_ast.py
The OutputAST class is responsible for printing the AST in a readable
and structured format. This allows users to inspect the parsed structure
of a COOL program. Notice that:

1. Structured Output: The AST is printed using recursive functions that
process each node in the tree, formatting output based on the node type
(e.g., class, method, attribute).
2. Custom Output Methods: For each type of node (method, attribute,
dispatch),  a specific function prints the node in a standardized format.
This ensures clarity and consistency in the AST output.
3. StringIO Usage: The AST is constructed in memory using Python's
StringIO, which enables efficient string manipulation.


## About main.py
The CoolParser class contains the code for implementing a parser in
Python for the COOL language.  The parser works in conjunction with a
lexer and parses the tokenized input from a .cl-lex file, producing
an abstract syntax tree (AST). Key points to note include:

1. PLY (Python Lex-Yacc) Library: The parser is built using PLY,
where grammar rules are defined using functions starting with p_.
These functions describe the structure of the COOL language and how
to  parse different language constructs.
2. Grammar Rules: The parser contains rules for parsing core COOL
constructs, including classes, methods, attribute definitions,
expressions like if-else, while loops, and let expressions. Each
grammar rule is defined as a function that follows the PLY format.
3. Precedence Rules: Operator precedence is defined to resolve
ambiguities between operations like +, -, *, /, comparison operators,
and the isvoid and not operators.
4. Error Handling: The p_error method handles syntax errors in the
source code, printing an appropriate error message that includes the
line number and the unexpected token.
5. Token Management: The DummyLexer class processes the .cl-lex file
and provides tokens to the parser. Each token consists of a type, value,
and line number, which the parser uses to correctly associate tokens
with grammar rules.
6. AST Generation: After parsing, the program produces an Abstract
Syntax Tree (AST) which is then printed using the OutputAST class.
This AST includes nodes representing COOL constructs like classes,
methods, expressions, and variables.
